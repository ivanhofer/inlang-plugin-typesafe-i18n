{
  "version": 3,
  "sources": ["../node_modules/typesafe-i18n/config/index.mjs", "../src/utils/typesafe-i18n.utils.ts", "../node_modules/typesafe-i18n/parser/index.mjs", "../src/loadMessages.ts", "../node_modules/just-safe-set/index.mjs", "../node_modules/dedent/dist/dedent.mjs", "../src/saveMessages.ts", "../src/plugin.ts", "../src/index.ts"],
  "sourcesContent": ["// ../shared/src/file.utils.mts\nvar getFiles = async (fs, path, depth = 0) => {\n  const entries = await fs.readdir(path, { withFileTypes: true });\n  const files = entries.filter((file) => !file.isDirectory()).map(({ name }) => ({ name: name.toString(), folder: \"\" }));\n  const folders = entries.filter((folder) => folder.isDirectory());\n  if (depth) {\n    for (const folder of folders)\n      files.push(\n        ...(await getFiles(fs, `${path}/${folder.name}/`, depth - 1)).map((file) => ({\n          name: file.name.toString(),\n          folder: folder.name.toString()\n        }))\n      );\n  }\n  return files;\n};\nvar getAllLocales = async (fs, path, outputFormat) => {\n  const fileEnding = outputFormat === \"JavaScript\" ? \".js\" : \".ts\";\n  const files = await getFiles(fs, path, 1);\n  return files.filter(({ folder, name }) => folder && name === `index${fileEnding}`).map(({ folder }) => folder);\n};\n\n// src/core.mts\nvar applyDefaultValues = async (config) => ({\n  baseLocale: \"en\",\n  tempPath: \"./node_modules/typesafe-i18n/temp-output/\",\n  outputPath: \"./src/i18n/\",\n  outputFormat: \"TypeScript\",\n  typesFileName: \"i18n-types\",\n  utilFileName: \"i18n-util\",\n  formattersTemplateFileName: \"formatters\",\n  typesTemplateFileName: \"custom-types\",\n  esmImports: false,\n  adapter: void 0,\n  generateOnlyTypes: false,\n  banner: \"/* eslint-disable */\",\n  runAfterGenerator: void 0,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...config\n});\nvar readConfigFromDisk = async (fs) => {\n  const content = await fs.readFile(\".typesafe-i18n.json\").catch(() => \"{}\");\n  return JSON.parse(content.toString());\n};\nvar getConfig = async (fs) => {\n  const config = await readConfigFromDisk(fs);\n  return applyDefaultValues(config);\n};\nvar getLocaleInformation = async (fs) => {\n  const config = await getConfig(fs);\n  return {\n    base: config.baseLocale,\n    locales: await getAllLocales(fs, config.outputPath, config.outputFormat)\n  };\n};\nexport {\n  getConfig,\n  getLocaleInformation\n};\n", "import type { NodeishFilesystemSubset } from '@inlang/plugin'\nimport type { readdir } from \"node:fs/promises\"\n\n// ------------------------------------------------------------------------------------------------\n\n// TODO: test\nexport const getDictionaryForLocale = async (\n\t$fs: NodeishFilesystemSubset,\n\toutputPath: string,\n\tlocale: string\n) => {\n\t// TODO: create a better, less hacky version\n\tconst baseDictionary = await $fs.readFile(resolve(outputPath, `${locale}/index.ts`), { encoding: \"utf-8\" }).catch(() => undefined) as string\n\tif (!baseDictionary) return\n\n\tconst withoutImports = baseDictionary\n\t\t.split(\"\\n\")\n\t\t.filter((line) => !line.trim().startsWith(\"import \"))\n\t\t.join(\"\\n\")\n\tconst withoutTypes = withoutImports\n\t\t.replace(/const\\s\\w[^\\s]+\\s*(:\\s*\\w[^\\s]+\\s*)=/g, (match, type) => match.replace(type, \"\"))\n\tconst withoutSatisfies = withoutTypes.replace(/ satisfies.*\\/n/g, \"\\n\")\n\n\tconst moduleWithMimeType = \"data:application/javascript,\" + encodeURIComponent(withoutSatisfies)\n\treturn (await import(/* @vite-ignore */ moduleWithMimeType)).default\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport const patchFs = (fs: NodeishFilesystemSubset) => {\n\treturn {\n\t\t...fs,\n\t\treaddir: async (path: string, options?: Parameters<typeof readdir>[1]) => {\n\t\t\tconst result = await fs.readdir(path)\n\t\t\tif (!options?.withFileTypes) return result\n\n\t\t\treturn result.map(name => ({\n\t\t\t\tname,\n\t\t\t\tisDirectory: () => !(name.endsWith('.ts') || name.endsWith('.js')),\n\t\t\t}))\n\t\t},\n\t\treadFile: async (path: string) => {\n\t\t\tconst result = await fs.readFile(path)\n\n\t\t\treturn Buffer.from(result as unknown as string).toString()\n\t\t},\n\t} as unknown as NodeishFilesystemSubset\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport const resolve = (...parts: string[]): string =>\n\tparts\n\t\t.map((p) => {\n\t\t\twhile (p.startsWith(\"/\")) {\n\t\t\t\tp = p.substring(1)\n\t\t\t}\n\t\t\twhile (p.endsWith(\"/\")) {\n\t\t\t\tp = p.substring(0, p.length - 1)\n\t\t\t}\n\t\t\treturn p\n\t\t})\n\t\t.join(\"/\")\n", "// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isUndefined/isUndefined.js\nvar isNotUndefined = (value) => value !== void 0;\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isString/isString.js\nvar isString = (value) => typeof value === \"string\";\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/pick/pick.js\nvar pick = (property) => (value) => value[property];\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/uniqueArray/uniqueArray.js\nvar uniqueArray = (array) => Array.from(new Set(array));\n\n// src/basic.mts\nvar removeEmptyValues = (object) => Object.fromEntries(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Object.entries(object).map(([key, value]) => key !== \"i\" && value && value != \"0\" && [key, value]).filter(Boolean)\n);\nvar trimAllValues = (part) => Object.fromEntries(\n  Object.keys(part).map((key) => {\n    const val = part[key];\n    return [\n      key,\n      Array.isArray(val) ? val.map((v) => v?.trim()) : val === !!val ? val : val?.trim()\n    ];\n  })\n);\nvar parseArgumentPart = (text) => {\n  const [keyPart = \"\", ...formatterKeys] = text.split(\"|\");\n  const [keyWithoutType = \"\", type] = keyPart.split(\":\");\n  const [key, isOptional] = keyWithoutType.split(\"?\");\n  return { k: key, i: type, n: isOptional === \"\", f: formatterKeys };\n};\nvar isBasicPluralPart = (part) => !!(part.o || part.r);\nvar parsePluralPart = (content, lastAccessor) => {\n  let [key, values] = content.split(\":\");\n  if (!values) {\n    values = key;\n    key = lastAccessor;\n  }\n  const entries = values.split(\"|\");\n  const [zero, one, two, few, many, rest] = entries;\n  const nrOfEntries = entries.filter((entry) => entry !== void 0).length;\n  if (nrOfEntries === 1) {\n    return { k: key, r: zero };\n  }\n  if (nrOfEntries === 2) {\n    return { k: key, o: zero, r: one };\n  }\n  if (nrOfEntries === 3) {\n    return { k: key, z: zero, o: one, r: two };\n  }\n  return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };\n};\nvar REGEX_SWITCH_CASE = /^\\{.*\\}$/;\nvar parseCases = (text) => Object.fromEntries(\n  removeOuterBrackets(text).split(\",\").map((part) => part.split(\":\")).reduce(\n    (accumulator, entry) => {\n      if (entry.length === 2) {\n        return [...accumulator, entry.map((entry2) => entry2.trim())];\n      }\n      ;\n      accumulator[accumulator.length - 1][1] += \",\" + entry[0];\n      return accumulator;\n    },\n    []\n  )\n);\nvar REGEX_BRACKETS_SPLIT = /(\\{(?:[^{}]+|\\{(?:[^{}]+)*\\})*\\})/g;\nvar removeOuterBrackets = (text) => text.substring(1, text.length - 1);\nvar parseRawText = (rawText, optimize = true, firstKey = \"\", lastKey = \"\") => rawText.split(REGEX_BRACKETS_SPLIT).map((part) => {\n  if (!part.match(REGEX_BRACKETS_SPLIT)) {\n    return part;\n  }\n  const content = removeOuterBrackets(part);\n  if (content.startsWith(\"{\")) {\n    return parsePluralPart(removeOuterBrackets(content), lastKey);\n  }\n  const parsedPart = parseArgumentPart(content);\n  lastKey = parsedPart.k || lastKey;\n  !firstKey && (firstKey = lastKey);\n  return parsedPart;\n}).map((part) => {\n  if (typeof part === \"string\")\n    return part;\n  if (!part.k)\n    part.k = firstKey || \"0\";\n  const trimmed = trimAllValues(part);\n  return optimize ? removeEmptyValues(trimmed) : trimmed;\n});\n\n// src/advanced/parse.mts\nvar isTextPart = (part) => part.kind === \"text\";\nvar isPluralPart = (part) => part.kind === \"plural\";\nvar isParameterPart = (part) => part.kind === \"parameter\";\nvar isTransformParameterSwitchCasePart = (part) => part.kind === \"switch-case\";\nvar parseMessage = (message) => enhanceTypeInformation(parseRawText(message, false).map(createPart).filter(isNotUndefined));\nvar createPart = (part) => {\n  if (isString(part)) {\n    return part ? createTextPart(part) : void 0;\n  }\n  if (isBasicPluralPart(part))\n    return createPluralPart(part);\n  return createParameterPart(part);\n};\nvar createTextPart = (content) => ({\n  kind: \"text\",\n  content\n});\nvar createPluralPart = ({ k, z, o, t, f, m, r }) => ({\n  kind: \"plural\",\n  key: k,\n  ...z ? { zero: z } : void 0,\n  ...o ? { one: o } : void 0,\n  ...t ? { two: t } : void 0,\n  ...f ? { few: f } : void 0,\n  ...m ? { many: m } : void 0,\n  other: r\n});\nvar createParameterPart = ({ k, i, n, f }) => ({\n  kind: \"parameter\",\n  key: k,\n  types: i ? [i] : [],\n  optional: n || false,\n  transforms: (f || []).map(createTransformParameterPart)\n});\nvar createTransformParameterPart = (transform) => {\n  const isSwitchCase = transform.match(REGEX_SWITCH_CASE);\n  return isSwitchCase ? {\n    kind: \"switch-case\",\n    cases: Object.entries(parseCases(transform)).map(([key, value]) => ({ key, value })),\n    raw: transform\n  } : {\n    kind: \"formatter\",\n    name: transform\n  };\n};\nvar enhanceTypeInformation = (parts) => {\n  const parameterParts = parts.filter(isParameterPart);\n  const pluralParts = parts.filter(isPluralPart);\n  const typeMap = {};\n  parameterParts.forEach(({ key, types, transforms, optional }) => {\n    const enhancedTypes = types.length ? types : parseTypesFromSwitchCaseStatement(transforms);\n    typeMap[key] = {\n      types: uniqueArray([...typeMap[key]?.types || [], ...enhancedTypes]).filter(isNotUndefined),\n      optional: typeMap[key]?.optional || optional\n    };\n  });\n  pluralParts.forEach(({ key }) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"string\", \"number\", \"boolean\"], optional: false };\n    }\n  });\n  Object.keys(typeMap).forEach((key) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"unknown\"], optional: typeMap[key]?.optional || false };\n    }\n  });\n  Object.entries(typeMap).forEach(([key, value]) => {\n    const part = parameterParts.find((p) => p.key === key);\n    if (!part)\n      return;\n    part.types = value.types;\n    part.optional = part.optional || value.optional;\n  });\n  return parts;\n};\nvar parseTypesFromSwitchCaseStatement = (formatters) => {\n  if (!formatters?.length)\n    return [];\n  const formatter = formatters[0];\n  if (!isTransformParameterSwitchCasePart(formatter))\n    return [];\n  const keys = formatter.cases.map(pick(\"key\"));\n  return keys.map((key) => key === \"*\" ? \"string\" : `'${key}'`);\n};\n\n// src/advanced/serialize.mts\nvar serializeMessage = (parts) => parts.map(serializePart).join(\"\");\nvar serializePart = (part) => {\n  if (isTextPart(part))\n    return part.content;\n  if (isPluralPart(part))\n    return serializePluralPart(part);\n  return serializeParameterPart(part);\n};\nvar serializePluralPart = ({ zero, one, two, few, many, other }) => `{{${[zero, one, two, few, many, other].filter((value) => value !== void 0).join(\"|\")}}}`;\nvar serializeParameterPart = ({ key, optional, types, transforms }) => {\n  const type = types.length === 1 ? types[0] === \"unknown\" ? void 0 : types[0] : void 0;\n  return `{${key}${type ? `:${type}` : \"\"}${optional ? \"?\" : \"\"}${transforms.length ? `|${transforms.map(serializeTransformPart).join(\"|\")}` : \"\"}}`;\n};\nvar serializeTransformPart = (transform) => transform.kind === \"formatter\" ? transform.name : transform.raw || serializeTransformSwitchCasePart(transform);\nvar serializeTransformSwitchCasePart = (part) => `{${part.cases.map(({ key, value }) => `${key}:${value}`).join(\",\")}}`;\nexport {\n  parseMessage as experimentalParseMessage,\n  serializeMessage as experimentalSerializeMessage\n};\n", "import type { Message, Plugin } from \"@inlang/plugin\"\nimport type { Pattern, Text, VariableReference } from \"@inlang/messages\"\nimport { getConfig } from 'typesafe-i18n/config'\nimport type { BaseTranslation } from 'typesafe-i18n'\nimport { getDictionaryForLocale, patchFs } from './utils/typesafe-i18n.utils.js'\nimport { experimentalParseMessage, type ParameterPart, type PluralPart } from 'typesafe-i18n/parser'\n\ntype DictionaryMetadata = {\n\tlanguageTag: string\n\tdictionary: BaseTranslation\n}\n\nexport const loadMessages = (async ({ nodeishFs, languageTags }) => {\n\tconst $fs = patchFs(nodeishFs)\n\n\t// @ts-expect-error - the types slightly differ; should work regardless\n\tconst typesafeI18nConfig = await getConfig($fs)\n\n\tconst dictionaries = (await Promise.all<DictionaryMetadata | undefined>(languageTags\n\t\t.map(async languageTag => {\n\t\t\tconst dictionary = await getDictionaryForLocale(\n\t\t\t\t$fs,\n\t\t\t\ttypesafeI18nConfig.outputPath,\n\t\t\t\tlanguageTag,\n\t\t\t)\n\n\t\t\tif (!dictionary) return\n\n\t\t\treturn {\n\t\t\t\tlanguageTag,\n\t\t\t\tdictionary,\n\t\t\t}\n\t\t})\n\t)).filter(Boolean) as DictionaryMetadata[]\n\n\treturn getMessagesFromDictionaries(dictionaries, typesafeI18nConfig.baseLocale)\n}) satisfies Plugin['loadMessages']\n\n// ------------------------------------------------------------------------------------------------\n\nconst getMessagesFromDictionaries = (dictionaries: DictionaryMetadata[], baseLocale: string): Message[] => {\n\tconst messages: Message[] = []\n\tfor (const { languageTag, dictionary } of dictionaries) {\n\t\tconst entries = getFlatDictionary(dictionary)\n\t\tfor (const entry of entries) {\n\t\t\tlet foundMessage = messages.find(({ id }) => id === entry.id)\n\t\t\tif (!foundMessage) {\n\t\t\t\tfoundMessage = { id: entry.id, selectors: [], body: {} }\n\t\t\t\tmessages.push(foundMessage)\n\t\t\t}\n\n\t\t\tconst isBaseLocale = languageTag === baseLocale\n\t\t\tfoundMessage.body[languageTag] = [{ match: {}, pattern: parsePattern(entry.value, globalMetadata[entry.id] ??= {}, isBaseLocale) }]\n\t\t}\n\t}\n\n\treturn messages\n}\n\ntype FlattenedDictionaryMetadata = { id: string, value: string }[]\n\nconst getFlatDictionary = (dictionary: BaseTranslation): FlattenedDictionaryMetadata => {\n\treturn Object.entries(dictionary).map(([id, value]) => getFlatDictionaryEntry(id, value)).flat()\n}\n\nconst getFlatDictionaryEntry = (id: string, value: BaseTranslation): FlattenedDictionaryMetadata => {\n\tif (typeof value === 'object') {\n\t\treturn Object.entries(value)\n\t\t\t.map(([entryId, entryValue]) => getFlatDictionaryEntry(`${id}.${entryId}`, entryValue))\n\t\t\t.flat()\n\t}\n\n\treturn [{ id, value }]\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport type ParameterMetadata = any\n\nexport const globalMetadata: Record<string, Record<string, ParameterMetadata>> = {}\n\nconst parsePattern = (value: string, metadataForLocale: Record<string, ParameterMetadata | undefined>, isBaseLocale: boolean): Pattern => {\n\tconst parsedMessage = experimentalParseMessage(value)\n\n\treturn parsedMessage.map(part => {\n\t\tswitch (part.kind) {\n\t\t\tcase 'parameter':\n\t\t\t\treturn parseParameter(part, metadataForLocale, isBaseLocale)\n\t\t\tcase 'text':\n\t\t\t\treturn { type: \"Text\", value: part.content }\n\t\t\tcase 'plural':\n\t\t\t\treturn parsePlural(part)\n\t\t}\n\t})\n\n}\n\nconst parseParameter = (parameterPart: ParameterPart, metadataForLocale: Record<string, ParameterMetadata | undefined>, isBaseLocale: boolean): VariableReference => {\n\n\tif (isBaseLocale) {\n\t\tmetadataForLocale[parameterPart.key] = {\n\t\t\ttypes: parameterPart.types,\n\t\t\toptional: parameterPart.optional,\n\t\t\ttransforms: parameterPart.transforms,\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: 'VariableReference',\n\t\tname: parameterPart.key,\n\t}\n}\n\n// TODO: make this more robust\nconst parsePlural = (pluralPart: PluralPart): Text => {\n\treturn {\n\t\ttype: \"Text\",\n\t\tvalue: `{{${[pluralPart.zero, pluralPart.one, pluralPart.two, pluralPart.few, pluralPart.many, pluralPart.other]\n\t\t\t.filter(Boolean)\n\t\t\t.join('|')\n\t\t\t}}}`\n\t}\n}", "var objectSafeSet = set;\n\n/*\n  var obj1 = {};\n  set(obj1, 'a.aa.aaa', 4); // true\n  obj1; // {a: {aa: {aaa: 4}}}\n\n  var obj2 = {};\n  set(obj2, ['a', 'aa', 'aaa'], 4); // true\n  obj2; // {a: {aa: {aaa: 4}}}\n\n  var obj3 = {a: {aa: {aaa: 2}}};\n  set(obj3, 'a.aa.aaa', 3); // true\n  obj3; // {a: {aa: {aaa: 3}}}\n\n  const obj5 = {a: {}};\n  const sym = Symbol();\n  set(obj5.a, sym, 7); // true\n  obj5; // {a: {Symbol(): 7}}\n*/\n\nfunction set(obj, propsArg, value) {\n  var props, lastProp;\n  if (Array.isArray(propsArg)) {\n    props = propsArg.slice(0);\n  }\n  if (typeof propsArg == 'string') {\n    props = propsArg.split('.');\n  }\n  if (typeof propsArg == 'symbol') {\n    props = [propsArg];\n  }\n  if (!Array.isArray(props)) {\n    throw new Error('props arg must be an array, a string or a symbol');\n  }\n  lastProp = props.pop();\n  if (!lastProp) {\n    return false;\n  }\n  prototypeCheck(lastProp);\n  var thisProp;\n  while ((thisProp = props.shift())) {\n    prototypeCheck(thisProp);\n    if (typeof obj[thisProp] == 'undefined') {\n      obj[thisProp] = {};\n    }\n    obj = obj[thisProp];\n    if (!obj || typeof obj != 'object') {\n      return false;\n    }\n  }\n  obj[lastProp] = value;\n  return true;\n}\n\nfunction prototypeCheck(prop) {\n  // coercion is intentional to catch prop values like `['__proto__']`\n  if (prop == '__proto__' || prop == 'constructor' || prop == 'prototype') {\n    throw new Error('setting of prototype values not supported');\n  }\n}\n\nexport {objectSafeSet as default};\n", "function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nexport default createDedent({});\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      escapeSpecialCharacters = Array.isArray(strings)\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += values[i];\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n    return result\n    // dedent eats leading and trailing whitespace too\n    .trim()\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    .replace(/\\\\n/g, \"\\n\");\n  }\n}\n", "import type { Message, Pattern, Plugin, VariableReference, Variant } from \"@inlang/plugin\"\nimport { patchFs, resolve } from './utils/typesafe-i18n.utils.js'\nimport { getConfig } from 'typesafe-i18n/config'\nimport type { BaseTranslation } from 'typesafe-i18n'\nimport set from 'just-safe-set'\nimport dedent from 'dedent'\nimport { globalMetadata, type ParameterMetadata } from './loadMessages.js'\n\ntype NodeishFs = Parameters<NonNullable<Plugin['saveMessages']>>[0]['nodeishFs']\n\n// ------------------------------------------------------------------------------------------------\n\nexport const saveMessages = (async ({ nodeishFs, messages }) => {\n\tconst $fs = patchFs(nodeishFs)\n\n\t// @ts-expect-error - the types slightly differ; should work regardless\n\tconst typesafeI18nConfig = await getConfig($fs)\n\n\tconst dictionaryMap = messagesToDictionaryMap(messages, typesafeI18nConfig.baseLocale)\n\n\tfor (const [locale, dictionary] of Object.entries(dictionaryMap)) {\n\t\tconst isReferenceLanguage = locale === typesafeI18nConfig.baseLocale\n\n\t\tconst type = isReferenceLanguage ? \"BaseTranslation\" : \"Translation\"\n\t\t// TODO: path could be wrong if esmImports=true\n\t\t// TODO: write correct path for namespaces\n\t\t// TODO: export utility type from `typesafe-i18n` to get correct string e.g. with `satisfies`\n\t\tconst template = dedent`\n\t\t\timport type { ${type} } from '../${typesafeI18nConfig.typesFileName}'\n\n\t\t\tconst ${locale}: ${type} = ${JSON.stringify(dictionary, null, 3)\n\t\t\t\t.split(/\\n/).map(text => '   ' + text).join('\\n')}\n\n\t\t\texport default ${locale}\n\t\t`\n\n\t\tawait createFoldersIfMissing($fs, resolve(typesafeI18nConfig.outputPath, locale))\n\n\t\tawait $fs.writeFile(\n\t\t\tresolve(typesafeI18nConfig.outputPath, `${locale}/index.ts`),\n\t\t\ttemplate\n\t\t)\n\t}\n}) satisfies Plugin['saveMessages']\n\n// ------------------------------------------------------------------------------------------------\n\nconst createFoldersIfMissing = async ($fs: NodeishFs, path: string): Promise<void> => {\n\tconst pathParts = path.split('/')\n\tlet currentPath = ''\n\tfor (const part of pathParts) {\n\t\tcurrentPath += part + '/'\n\t\tif (!(await $fs.readdir(currentPath).catch(() => undefined))) {\n\t\t\tawait $fs.mkdir(currentPath)\n\t\t}\n\t}\n}\n\n// ------------------------------------------------------------------------------------------------\n\nconst messagesToDictionaryMap = (messages: Message[], baseLocale: string): Record<string, BaseTranslation> => {\n\tconst dictionaries: Record<string, BaseTranslation> = {}\n\n\tfor (const message of messages) {\n\t\tfor (const languageTag in message.body) {\n\t\t\tconst dictionary = dictionaries[languageTag] ??= {}\n\t\t\tconst isBaseLocale = languageTag === baseLocale\n\t\t\tset(dictionary, message.id, serializeVariants(message.body[languageTag], globalMetadata[message.id], isBaseLocale))\n\t\t}\n\t}\n\n\treturn dictionaries\n}\n\n// ------------------------------------------------------------------------------------------------\n\nconst serializeVariants = (variants: Variant[], metadataForLocale: Record<string, ParameterMetadata | undefined>, isBaseLocale: boolean): string => {\n\treturn serializePattern(variants[0]?.pattern || [], metadataForLocale, isBaseLocale)\n}\n\nconst serializePattern = (pattern: Pattern, metadataForLocale: Record<string, ParameterMetadata | undefined>, isBaseLocale: boolean): string => {\n\treturn pattern.map((patternElement) => serializePatternElement(patternElement, metadataForLocale, isBaseLocale)).join(\"\")\n}\n\nconst serializePatternElement = (\n\telement: Pattern[number],\n\tmetadataForLocale: Record<string, ParameterMetadata | undefined>,\n\tisReferenceLanguage: boolean\n): string => {\n\tswitch (element.type) {\n\t\tcase \"Text\":\n\t\t\treturn element.value\n\t\tcase \"VariableReference\":\n\t\t\treturn serializeParameter(element, metadataForLocale, isReferenceLanguage)\n\t}\n}\n\nconst serializeParameter = ({ name }: VariableReference, metadataForLocale: Record<string, ParameterMetadata | undefined>, isReferenceLanguage: boolean): string => {\n\tlet str = name\n\n\tconst metadata = (metadataForLocale || {})[name]\n\tif (isReferenceLanguage && metadata) {\n\t\tif (metadata.optional) str += \"?\"\n\t\tif (metadata.types?.length > 0) {\n\t\t\tif (!(metadata.types.length === 3\n\t\t\t\t&& metadata.types.includes(\"string\")\n\t\t\t\t&& metadata.types.includes(\"number\")\n\t\t\t\t&& metadata.types.includes(\"boolean\"))\n\t\t\t) {\n\t\t\t\tstr += `:${metadata.types[0]}`\n\t\t\t}\n\t\t}\n\t}\n\tif (metadata?.transforms?.length > 0) {\n\t\tstr += `|${metadata.transforms.map(({ name }: any) => name).join(\"|\")}`\n\t}\n\treturn `{${str}}`\n}", "import type { Plugin } from \"@inlang/plugin\"\nimport { loadMessages } from './loadMessages.js'\nimport { saveMessages } from './saveMessages.js'\n\nexport const plugin = {\n  meta: {\n    id: \"ivanhofer.inlang-plugin-typesafe-i18n\",\n    displayName: { en: \"typesafe-i18n plugin\" },\n    description: { en: \"A plugin for inlang that uses typesafe-i18n to read and write messages\" },\n    keywords: [\"inlang\", \"plugin\", \"typesafe-i18n\", \"TypeScript\"],\n  },\n  loadMessages,\n  saveMessages,\n} satisfies Plugin\n", "import type { InlangModule } from \"@inlang/module\"\nimport { plugin } from './plugin.js'\n\nexport default {\n\tplugins: [plugin],\n} satisfies InlangModule['default']"],
  "mappings": "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",
  "names": ["applyDefaultValues", "config", "readConfigFromDisk", "fs", "content", "getConfig", "getDictionaryForLocale", "$fs", "outputPath", "locale", "baseDictionary", "resolve", "withoutSatisfies", "line", "match", "type", "patchFs", "fs", "path", "options", "result", "name", "parts", "p", "isNotUndefined", "value", "isString", "pick", "property", "uniqueArray", "array", "removeEmptyValues", "object", "key", "trimAllValues", "part", "val", "v", "parseArgumentPart", "text", "keyPart", "formatterKeys", "keyWithoutType", "type", "isOptional", "isBasicPluralPart", "parsePluralPart", "content", "lastAccessor", "values", "entries", "zero", "one", "two", "few", "many", "rest", "nrOfEntries", "entry", "REGEX_SWITCH_CASE", "parseCases", "removeOuterBrackets", "accumulator", "entry2", "REGEX_BRACKETS_SPLIT", "parseRawText", "rawText", "optimize", "firstKey", "lastKey", "parsedPart", "trimmed", "isPluralPart", "part", "isParameterPart", "isTransformParameterSwitchCasePart", "parseMessage", "message", "enhanceTypeInformation", "parseRawText", "createPart", "isNotUndefined", "isString", "createTextPart", "isBasicPluralPart", "createPluralPart", "createParameterPart", "content", "k", "z", "o", "t", "f", "m", "r", "i", "n", "createTransformParameterPart", "transform", "REGEX_SWITCH_CASE", "parseCases", "key", "value", "parts", "parameterParts", "pluralParts", "typeMap", "types", "transforms", "optional", "enhancedTypes", "parseTypesFromSwitchCaseStatement", "uniqueArray", "formatters", "formatter", "pick", "loadMessages", "nodeishFs", "languageTags", "$fs", "patchFs", "typesafeI18nConfig", "getConfig", "dictionaries", "languageTag", "dictionary", "getDictionaryForLocale", "getMessagesFromDictionaries", "baseLocale", "_a", "messages", "entries", "getFlatDictionary", "entry", "foundMessage", "id", "isBaseLocale", "parsePattern", "globalMetadata", "value", "getFlatDictionaryEntry", "entryId", "entryValue", "metadataForLocale", "parseMessage", "part", "parseParameter", "parsePlural", "parameterPart", "pluralPart", "objectSafeSet", "set", "obj", "propsArg", "value", "props", "lastProp", "prototypeCheck", "thisProp", "prop", "ownKeys", "object", "enumerableOnly", "keys", "symbols", "sym", "_objectSpread", "target", "i", "source", "key", "_defineProperty", "obj", "value", "_toPropertyKey", "arg", "_toPrimitive", "input", "hint", "prim", "res", "dedent_default", "createDedent", "options", "dedent", "newOptions", "strings", "values", "raw", "escapeSpecialCharacters", "result", "next", "lines", "mindent", "m", "indent", "l", "saveMessages", "nodeishFs", "messages", "$fs", "patchFs", "typesafeI18nConfig", "getConfig", "dictionaryMap", "messagesToDictionaryMap", "locale", "dictionary", "type", "template", "dedent_default", "text", "createFoldersIfMissing", "resolve", "path", "pathParts", "currentPath", "part", "baseLocale", "dictionaries", "message", "languageTag", "isBaseLocale", "objectSafeSet", "serializeVariants", "globalMetadata", "variants", "metadataForLocale", "serializePattern", "pattern", "patternElement", "serializePatternElement", "element", "isReferenceLanguage", "serializeParameter", "name", "str", "metadata", "plugin", "loadMessages", "saveMessages", "src_default", "plugin"]
}
