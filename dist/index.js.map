{
  "version": 3,
  "sources": ["../node_modules/typesafe-i18n/config/index.mjs", "../node_modules/@inlang/core/dist/plugin/createPlugin.js", "../node_modules/typesafe-i18n/parser/index.mjs", "../src/utils.ts", "../src/readResources.ts", "../src/writeResources.ts", "../src/plugin.ts"],
  "sourcesContent": ["// ../shared/src/file.utils.mts\nvar getFiles = async (fs, path, depth = 0) => {\n  const entries = await fs.readdir(path, { withFileTypes: true });\n  const files = entries.filter((file) => !file.isDirectory()).map(({ name }) => ({ name: name.toString(), folder: \"\" }));\n  const folders = entries.filter((folder) => folder.isDirectory());\n  if (depth) {\n    for (const folder of folders)\n      files.push(\n        ...(await getFiles(fs, `${path}/${folder.name}/`, depth - 1)).map((file) => ({\n          name: file.name.toString(),\n          folder: folder.name.toString()\n        }))\n      );\n  }\n  return files;\n};\nvar getAllLocales = async (fs, path, outputFormat) => {\n  const fileEnding = outputFormat === \"JavaScript\" ? \".js\" : \".ts\";\n  const files = await getFiles(fs, path, 1);\n  return files.filter(({ folder, name }) => folder && name === `index${fileEnding}`).map(({ folder }) => folder);\n};\n\n// src/core.mts\nvar applyDefaultValues = async (config) => ({\n  baseLocale: \"en\",\n  tempPath: \"./node_modules/typesafe-i18n/temp-output/\",\n  outputPath: \"./src/i18n/\",\n  outputFormat: \"TypeScript\",\n  typesFileName: \"i18n-types\",\n  utilFileName: \"i18n-util\",\n  formattersTemplateFileName: \"formatters\",\n  typesTemplateFileName: \"custom-types\",\n  esmImports: false,\n  adapter: void 0,\n  generateOnlyTypes: false,\n  banner: \"/* eslint-disable */\",\n  runAfterGenerator: void 0,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...config\n});\nvar readConfigFromDisk = async (fs) => {\n  const content = await fs.readFile(\".typesafe-i18n.json\").catch(() => \"{}\");\n  return JSON.parse(content.toString());\n};\nvar getConfig = async (fs) => {\n  const config = await readConfigFromDisk(fs);\n  return applyDefaultValues(config);\n};\nvar getLocaleInformation = async (fs) => {\n  const config = await getConfig(fs);\n  return {\n    base: config.baseLocale,\n    locales: await getAllLocales(fs, config.outputPath, config.outputFormat)\n  };\n};\nexport {\n  getConfig,\n  getLocaleInformation\n};\n", "export function createPlugin(callback) {\n    // @ts-expect-error - settings can be undefined which typescript complains about\n    //  that is okay though.\n    return (settings) => (env) => callback({ settings, env });\n}\n", "// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isUndefined/isUndefined.js\nvar isNotUndefined = (value) => value !== void 0;\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isString/isString.js\nvar isString = (value) => typeof value === \"string\";\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/pick/pick.js\nvar pick = (property) => (value) => value[property];\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/uniqueArray/uniqueArray.js\nvar uniqueArray = (array) => Array.from(new Set(array));\n\n// src/basic.mts\nvar removeEmptyValues = (object) => Object.fromEntries(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Object.entries(object).map(([key, value]) => key !== \"i\" && value && value != \"0\" && [key, value]).filter(Boolean)\n);\nvar trimAllValues = (part) => Object.fromEntries(\n  Object.keys(part).map((key) => {\n    const val = part[key];\n    return [\n      key,\n      Array.isArray(val) ? val.map((v) => v?.trim()) : val === !!val ? val : val?.trim()\n    ];\n  })\n);\nvar parseArgumentPart = (text) => {\n  const [keyPart = \"\", ...formatterKeys] = text.split(\"|\");\n  const [keyWithoutType = \"\", type] = keyPart.split(\":\");\n  const [key, isOptional] = keyWithoutType.split(\"?\");\n  return { k: key, i: type, n: isOptional === \"\", f: formatterKeys };\n};\nvar isBasicPluralPart = (part) => !!(part.o || part.r);\nvar parsePluralPart = (content, lastAccessor) => {\n  let [key, values] = content.split(\":\");\n  if (!values) {\n    values = key;\n    key = lastAccessor;\n  }\n  const entries = values.split(\"|\");\n  const [zero, one, two, few, many, rest] = entries;\n  const nrOfEntries = entries.filter((entry) => entry !== void 0).length;\n  if (nrOfEntries === 1) {\n    return { k: key, r: zero };\n  }\n  if (nrOfEntries === 2) {\n    return { k: key, o: zero, r: one };\n  }\n  if (nrOfEntries === 3) {\n    return { k: key, z: zero, o: one, r: two };\n  }\n  return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };\n};\nvar REGEX_SWITCH_CASE = /^\\{.*\\}$/;\nvar parseCases = (text) => Object.fromEntries(\n  removeOuterBrackets(text).split(\",\").map((part) => part.split(\":\")).reduce(\n    (accumulator, entry) => {\n      if (entry.length === 2) {\n        return [...accumulator, entry.map((entry2) => entry2.trim())];\n      }\n      ;\n      accumulator[accumulator.length - 1][1] += \",\" + entry[0];\n      return accumulator;\n    },\n    []\n  )\n);\nvar REGEX_BRACKETS_SPLIT = /(\\{(?:[^{}]+|\\{(?:[^{}]+)*\\})*\\})/g;\nvar removeOuterBrackets = (text) => text.substring(1, text.length - 1);\nvar parseRawText = (rawText, optimize = true, firstKey = \"\", lastKey = \"\") => rawText.split(REGEX_BRACKETS_SPLIT).map((part) => {\n  if (!part.match(REGEX_BRACKETS_SPLIT)) {\n    return part;\n  }\n  const content = removeOuterBrackets(part);\n  if (content.startsWith(\"{\")) {\n    return parsePluralPart(removeOuterBrackets(content), lastKey);\n  }\n  const parsedPart = parseArgumentPart(content);\n  lastKey = parsedPart.k || lastKey;\n  !firstKey && (firstKey = lastKey);\n  return parsedPart;\n}).map((part) => {\n  if (typeof part === \"string\")\n    return part;\n  if (!part.k)\n    part.k = firstKey || \"0\";\n  const trimmed = trimAllValues(part);\n  return optimize ? removeEmptyValues(trimmed) : trimmed;\n});\n\n// src/advanced/parse.mts\nvar isTextPart = (part) => part.kind === \"text\";\nvar isPluralPart = (part) => part.kind === \"plural\";\nvar isParameterPart = (part) => part.kind === \"parameter\";\nvar isTransformParameterSwitchCasePart = (part) => part.kind === \"switch-case\";\nvar parseMessage = (message) => enhanceTypeInformation(parseRawText(message, false).map(createPart).filter(isNotUndefined));\nvar createPart = (part) => {\n  if (isString(part)) {\n    return part ? createTextPart(part) : void 0;\n  }\n  if (isBasicPluralPart(part))\n    return createPluralPart(part);\n  return createParameterPart(part);\n};\nvar createTextPart = (content) => ({\n  kind: \"text\",\n  content\n});\nvar createPluralPart = ({ k, z, o, t, f, m, r }) => ({\n  kind: \"plural\",\n  key: k,\n  ...z ? { zero: z } : void 0,\n  ...o ? { one: o } : void 0,\n  ...t ? { two: t } : void 0,\n  ...f ? { few: f } : void 0,\n  ...m ? { many: m } : void 0,\n  other: r\n});\nvar createParameterPart = ({ k, i, n, f }) => ({\n  kind: \"parameter\",\n  key: k,\n  types: i ? [i] : [],\n  optional: n || false,\n  transforms: (f || []).map(createTransformParameterPart)\n});\nvar createTransformParameterPart = (transform) => {\n  const isSwitchCase = transform.match(REGEX_SWITCH_CASE);\n  return isSwitchCase ? {\n    kind: \"switch-case\",\n    cases: Object.entries(parseCases(transform)).map(([key, value]) => ({ key, value })),\n    raw: transform\n  } : {\n    kind: \"formatter\",\n    name: transform\n  };\n};\nvar enhanceTypeInformation = (parts) => {\n  const parameterParts = parts.filter(isParameterPart);\n  const pluralParts = parts.filter(isPluralPart);\n  const typeMap = {};\n  parameterParts.forEach(({ key, types, transforms, optional }) => {\n    const enhancedTypes = types.length ? types : parseTypesFromSwitchCaseStatement(transforms);\n    typeMap[key] = {\n      types: uniqueArray([...typeMap[key]?.types || [], ...enhancedTypes]).filter(isNotUndefined),\n      optional: typeMap[key]?.optional || optional\n    };\n  });\n  pluralParts.forEach(({ key }) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"string\", \"number\", \"boolean\"], optional: false };\n    }\n  });\n  Object.keys(typeMap).forEach((key) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"unknown\"], optional: typeMap[key]?.optional || false };\n    }\n  });\n  Object.entries(typeMap).forEach(([key, value]) => {\n    const part = parameterParts.find((p) => p.key === key);\n    if (!part)\n      return;\n    part.types = value.types;\n    part.optional = part.optional || value.optional;\n  });\n  return parts;\n};\nvar parseTypesFromSwitchCaseStatement = (formatters) => {\n  if (!formatters?.length)\n    return [];\n  const formatter = formatters[0];\n  if (!isTransformParameterSwitchCasePart(formatter))\n    return [];\n  const keys = formatter.cases.map(pick(\"key\"));\n  return keys.map((key) => key === \"*\" ? \"string\" : `'${key}'`);\n};\n\n// src/advanced/serialize.mts\nvar serializeMessage = (parts) => parts.map(serializePart).join(\"\");\nvar serializePart = (part) => {\n  if (isTextPart(part))\n    return part.content;\n  if (isPluralPart(part))\n    return serializePluralPart(part);\n  return serializeParameterPart(part);\n};\nvar serializePluralPart = ({ zero, one, two, few, many, other }) => `{{${[zero, one, two, few, many, other].filter((value) => value !== void 0).join(\"|\")}}}`;\nvar serializeParameterPart = ({ key, optional, types, transforms }) => {\n  const type = types.length === 1 ? types[0] === \"unknown\" ? void 0 : types[0] : void 0;\n  return `{${key}${type ? `:${type}` : \"\"}${optional ? \"?\" : \"\"}${transforms.length ? `|${transforms.map(serializeTransformPart).join(\"|\")}` : \"\"}}`;\n};\nvar serializeTransformPart = (transform) => transform.kind === \"formatter\" ? transform.name : transform.raw || serializeTransformSwitchCasePart(transform);\nvar serializeTransformSwitchCasePart = (part) => `{${part.cases.map(({ key, value }) => `${key}:${value}`).join(\",\")}}`;\nexport {\n  parseMessage as experimentalParseMessage,\n  serializeMessage as experimentalSerializeMessage\n};\n", "import type { InlangEnvironment } from '@inlang/core/environment'\nimport type { readdir } from \"node:fs/promises\"\n\nexport const patchFs = (fs: InlangEnvironment[\"$fs\"]) => {\n\treturn {\n\t\t...fs,\n\t\treaddir: async (path: string, options?: Parameters<typeof readdir>[1]) => {\n\t\t\tconst result = await fs.readdir(path)\n\t\t\tif (!options?.withFileTypes) return result\n\n\t\t\treturn result.map(name => ({\n\t\t\t\tname,\n\t\t\t\tisDirectory: () => !(name.endsWith('.ts') || name.endsWith('.js')),\n\t\t\t}))\n\t\t}\n\t} as unknown as InlangEnvironment[\"$fs\"]\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport const resolve = (...parts: string[]): string =>\n\tparts\n\t\t.map((p) => {\n\t\t\twhile (p.startsWith(\"/\")) {\n\t\t\t\tp = p.substring(1)\n\t\t\t}\n\t\t\twhile (p.endsWith(\"/\")) {\n\t\t\t\tp = p.substring(0, p.length - 1)\n\t\t\t}\n\t\t\treturn p\n\t\t})\n\t\t.join(\"/\")\n\n", "import type { InlangConfig } from \"@inlang/core/config\"\nimport type { InlangEnvironment } from \"@inlang/core/environment\"\nimport type * as ast from \"@inlang/core/ast\"\nimport { getConfig } from \"typesafe-i18n/config\"\nimport { experimentalParseMessage, type ParameterPart, type PluralPart } from \"typesafe-i18n/parser\"\nimport { patchFs, resolve } from './utils.js'\n\ntype ReadResourcesArgs = Parameters<InlangConfig[\"readResources\"]>[0] &\n\tInlangEnvironment\n\nexport async function readResources({\n\tconfig,\n\t$fs: rawFs,\n}: ReadResourcesArgs): ReturnType<InlangConfig[\"readResources\"]> {\n\tconst $fs = patchFs(rawFs)\n\n\t// @ts-expect-error - the types slightly differ; should work regardless\n\tconst typesafeI18nConfig = await getConfig($fs)\n\n\tconst result: ast.Resource[] = []\n\tfor (const language of config.languages) {\n\t\tconst dictionary = await getDictionaryForLocale(\n\t\t\t$fs,\n\t\t\ttypesafeI18nConfig.outputPath,\n\t\t\tlanguage\n\t\t)\n\t\tresult.push(parseResource(dictionary, language))\n\t}\n\n\treturn result\n}\n\nconst getDictionaryForLocale = async (\n\t$fs: InlangEnvironment[\"$fs\"],\n\toutputPath: string,\n\tlocale: string\n) => {\n\t// TODO: create a better, less hacky version\n\tconst baseDictionary = await $fs.readFile(resolve(outputPath, `${locale}/index.ts`), { encoding: \"utf-8\" }) as string\n\n\tconst withoutImports = baseDictionary\n\t\t.split(\"\\n\")\n\t\t.filter((line) => !line.trim().startsWith(\"import \"))\n\t\t.join(\"\\n\")\n\tconst withoutTypes = withoutImports\n\t\t.replace(/const\\s\\w[^\\s]+\\s*(:\\s*\\w[^\\s]+\\s*)=/g, (match, type) => match.replace(type, \"\"))\n\tconst withoutSatisfies = withoutTypes.replace(/ satisfies.*\\/n/g, \"\\n\")\n\n\tconst moduleWithMimeType = \"data:application/javascript,\" + encodeURIComponent(withoutSatisfies)\n\treturn (await import(/* @vite-ignore */ moduleWithMimeType)).default\n}\n\nconst parseResource = (\n\tflatJson: Record<string, string>,\n\tlocale: string\n): ast.Resource => {\n\treturn {\n\t\ttype: \"Resource\",\n\t\tlanguageTag: {\n\t\t\ttype: \"LanguageTag\",\n\t\t\tname: locale,\n\t\t},\n\t\tbody: Object.entries(flatJson).map(([id, value]) =>\n\t\t\tparseMessage(id, value)\n\t\t).flat(),\n\t}\n}\n\nconst parseMessage = (id: string, value: string | Record<string, string>): ast.Message | ast.Message[] => {\n\tif (typeof value === 'object')\n\t\treturn Object.entries(value).map(([entryId, entryValue]) =>\n\t\t\tparseMessage(`${id}.${entryId}`, entryValue)\n\t\t).flat()\n\n\tconst parsedMessage = experimentalParseMessage(value)\n\n\treturn {\n\t\ttype: \"Message\",\n\t\tid: {\n\t\t\ttype: \"Identifier\",\n\t\t\tname: id,\n\t\t},\n\t\tpattern: {\n\t\t\ttype: \"Pattern\",\n\t\t\telements: parsedMessage.map(part => {\n\t\t\t\tswitch (part.kind) {\n\t\t\t\t\tcase 'parameter':\n\t\t\t\t\t\treturn parseParameter(part)\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\treturn { type: \"Text\", value: part.content }\n\t\t\t\t\tcase 'plural':\n\t\t\t\t\t\treturn parsePlural(part)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t}\n}\n\nconst parseParameter = (parameterPart: ParameterPart): ast.Placeholder => {\n\treturn {\n\t\ttype: \"Placeholder\",\n\t\tbody: {\n\t\t\ttype: 'VariableReference',\n\t\t\tname: parameterPart.key,\n\t\t\tmetadata: {\n\t\t\t\ttypes: parameterPart.types,\n\t\t\t\toptional: parameterPart.optional,\n\t\t\t\ttransforms: parameterPart.transforms,\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: make this more robust\nconst parsePlural = (pluralPart: PluralPart): ast.Text => {\n\treturn {\n\t\ttype: \"Text\",\n\t\tvalue: `{{${[pluralPart.zero, pluralPart.one, pluralPart.two, pluralPart.few, pluralPart.many, pluralPart.other]\n\t\t\t.filter(Boolean)\n\t\t\t.join('|')\n\t\t\t}}}`\n\t}\n}", "import type { InlangConfig } from \"@inlang/core/config\"\nimport type { InlangEnvironment } from \"@inlang/core/environment\"\nimport type * as ast from \"@inlang/core/ast\"\nimport { getConfig } from \"typesafe-i18n/config\"\nimport { patchFs, resolve } from './utils.js'\n\ntype WriteResourcesArgs = Parameters<InlangConfig[\"writeResources\"]>[0] &\n\tInlangEnvironment\n\nexport async function writeResources({\n\t$fs: rawFs,\n\tconfig,\n\tresources,\n}: WriteResourcesArgs): ReturnType<InlangConfig[\"writeResources\"]> {\n\tconst $fs = patchFs(rawFs)\n\n\t// @ts-expect-error - the types slightly differ; should work regardless\n\tconst typesafeI18nConfig = await getConfig($fs)\n\n\tfor (const resource of resources) {\n\t\tconst locale = resource.languageTag.name\n\t\tconst isReferenceLanguage = locale === config.referenceLanguage\n\t\tconst dictionary = serializeResource(resource, isReferenceLanguage)\n\n\t\tconst type = isReferenceLanguage ? \"BaseTranslation\" : \"Translation\"\n\t\t// TODO: path could be wrong if esmImports=true\n\t\t// TODO: write correct path for namespaces\n\t\t// TODO: export utility type from `typesafe-i18n` to get correct string e.g. with `satisfies`\n\t\tconst template = `import type { ${type} } from '../${typesafeI18nConfig.typesFileName}'\nconst ${locale}: ${type} = ${dictionary}\n\nexport default ${locale}`\n\n\t\tawait $fs.writeFile(\n\t\t\tresolve(typesafeI18nConfig.outputPath, `${locale}/index.ts`),\n\t\t\ttemplate\n\t\t)\n\t}\n}\n\nconst serializeResource = (resource: ast.Resource, isReferenceLanguage: boolean): string => {\n\tconst json = {} as Record<string, any>\n\n\tresource.body.map((message) => serializeMessage(message, isReferenceLanguage)).forEach(([id, value]) => {\n\t\tconst idParts = id.split('.')\n\t\tlet current = json\n\t\tfor (let i = 0; i < idParts.length; i++) {\n\t\t\tconst part = idParts[i]\n\t\t\tif (i === idParts.length - 1) {\n\t\t\t\tcurrent[part] = value\n\t\t\t} else {\n\t\t\t\tif (!current[part]) current[part] = {}\n\t\t\t\tcurrent = current[part]\n\t\t\t}\n\t\t}\n\t})\n\t// stringify the object with beautification\n\treturn JSON.stringify(json, null, 3)\n}\n\nconst serializeMessage = (message: ast.Message, isReferenceLanguage: boolean): [id: string, value: string] => {\n\treturn [message.id.name, serializePattern(message.pattern, isReferenceLanguage)]\n}\n\nconst serializePattern = (pattern: ast.Pattern, isReferenceLanguage: boolean): string => {\n\treturn pattern.elements.map((patternElement) => serializePatternElement(patternElement, isReferenceLanguage)).join(\"\")\n}\n\nconst serializePatternElement = (\n\telement: ast.Pattern[\"elements\"][number],\n\tisReferenceLanguage: boolean\n): string => {\n\tswitch (element.type) {\n\t\tcase \"Text\":\n\t\t\treturn element.value\n\t\tcase \"Placeholder\":\n\t\t\treturn serializePlaceholder(element, isReferenceLanguage)\n\t}\n}\n\nconst serializePlaceholder = ({ body: { name, metadata = {} } }: ast.Placeholder, isReferenceLanguage: boolean): string => {\n\tlet str = name\n\tif (isReferenceLanguage) {\n\t\tif (metadata.optional) str += \"?\"\n\t\tif (metadata.types?.length > 0) {\n\t\t\tif (!(metadata.types.length === 3\n\t\t\t\t&& metadata.types.includes(\"string\")\n\t\t\t\t&& metadata.types.includes(\"number\")\n\t\t\t\t&& metadata.types.includes(\"boolean\"))\n\t\t\t) {\n\t\t\t\tstr += `:${metadata.types[0]}`\n\t\t\t}\n\t\t}\n\t}\n\tif (metadata.transforms?.length > 0) {\n\t\tstr += `|${metadata.transforms.map(({ name }: any) => name).join(\"|\")}`\n\t}\n\treturn `{${str}}`\n}", "import { getLocaleInformation } from \"typesafe-i18n/config\"\nimport { createPlugin } from \"@inlang/core/plugin\"\nimport { readResources } from './readResources.js'\nimport { writeResources } from './writeResources.js'\nimport { patchFs } from './utils.js'\n\n// issues:\n//  - real typescript compilation does not work\n\nexport const plugin = createPlugin(({ env }) => ({\n  id: \"ivanhofer.inlang-plugin-typesafe-i18n\",\n  async config() {\n    // @ts-expect-error - the types slightly differ; should work regardless\n    const { base, locales } = await getLocaleInformation(patchFs(env.$fs))\n\n    return {\n      referenceLanguage: base,\n      languages: locales,\n      readResources: ({ config }) => readResources({ config, ...env }),\n      writeResources: ({ config, resources }) => writeResources({ config, resources, ...env }),\n    }\n  },\n}))\n"],
  "mappings": "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",
  "names": ["getFiles", "fs", "path", "depth", "entries", "files", "file", "name", "folders", "folder", "getAllLocales", "outputFormat", "fileEnding", "applyDefaultValues", "config", "readConfigFromDisk", "content", "getConfig", "getLocaleInformation", "createPlugin", "callback", "settings", "env", "isNotUndefined", "value", "isString", "pick", "property", "uniqueArray", "array", "removeEmptyValues", "object", "key", "trimAllValues", "part", "val", "v", "parseArgumentPart", "text", "keyPart", "formatterKeys", "keyWithoutType", "type", "isOptional", "isBasicPluralPart", "parsePluralPart", "content", "lastAccessor", "values", "entries", "zero", "one", "two", "few", "many", "rest", "nrOfEntries", "entry", "REGEX_SWITCH_CASE", "parseCases", "removeOuterBrackets", "accumulator", "entry2", "REGEX_BRACKETS_SPLIT", "parseRawText", "rawText", "optimize", "firstKey", "lastKey", "parsedPart", "trimmed", "isPluralPart", "part", "isParameterPart", "isTransformParameterSwitchCasePart", "parseMessage", "message", "enhanceTypeInformation", "parseRawText", "createPart", "isNotUndefined", "isString", "createTextPart", "isBasicPluralPart", "createPluralPart", "createParameterPart", "content", "k", "z", "o", "t", "f", "m", "r", "i", "createTransformParameterPart", "transform", "REGEX_SWITCH_CASE", "parseCases", "key", "value", "parts", "parameterParts", "pluralParts", "typeMap", "types", "transforms", "optional", "enhancedTypes", "parseTypesFromSwitchCaseStatement", "uniqueArray", "p", "formatters", "formatter", "pick", "patchFs", "fs", "path", "options", "result", "name", "resolve", "parts", "p", "readResources", "config", "rawFs", "$fs", "patchFs", "typesafeI18nConfig", "getConfig", "result", "language", "dictionary", "getDictionaryForLocale", "parseResource", "outputPath", "locale", "withoutSatisfies", "resolve", "line", "match", "type", "flatJson", "id", "value", "parseMessage", "entryId", "entryValue", "parsedMessage", "part", "parseParameter", "parsePlural", "parameterPart", "pluralPart", "writeResources", "rawFs", "config", "resources", "$fs", "patchFs", "typesafeI18nConfig", "getConfig", "resource", "locale", "isReferenceLanguage", "dictionary", "serializeResource", "type", "template", "resolve", "json", "message", "serializeMessage", "id", "value", "idParts", "current", "i", "part", "serializePattern", "pattern", "patternElement", "serializePatternElement", "element", "serializePlaceholder", "name", "metadata", "str", "plugin", "createPlugin", "env", "base", "locales", "getLocaleInformation", "patchFs", "config", "readResources", "resources", "writeResources"]
}
