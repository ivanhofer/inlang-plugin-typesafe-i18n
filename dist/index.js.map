{
  "version": 3,
  "sources": ["../node_modules/typesafe-i18n/config/index.mjs", "../src/typesafe-i18n.utils.ts", "../node_modules/typesafe-i18n/parser/index.mjs", "../src/loadMessages.ts", "../src/writeMessages.ts", "../src/plugin.ts", "../src/index.ts"],
  "sourcesContent": ["// ../shared/src/file.utils.mts\nvar getFiles = async (fs, path, depth = 0) => {\n  const entries = await fs.readdir(path, { withFileTypes: true });\n  const files = entries.filter((file) => !file.isDirectory()).map(({ name }) => ({ name: name.toString(), folder: \"\" }));\n  const folders = entries.filter((folder) => folder.isDirectory());\n  if (depth) {\n    for (const folder of folders)\n      files.push(\n        ...(await getFiles(fs, `${path}/${folder.name}/`, depth - 1)).map((file) => ({\n          name: file.name.toString(),\n          folder: folder.name.toString()\n        }))\n      );\n  }\n  return files;\n};\nvar getAllLocales = async (fs, path, outputFormat) => {\n  const fileEnding = outputFormat === \"JavaScript\" ? \".js\" : \".ts\";\n  const files = await getFiles(fs, path, 1);\n  return files.filter(({ folder, name }) => folder && name === `index${fileEnding}`).map(({ folder }) => folder);\n};\n\n// src/core.mts\nvar applyDefaultValues = async (config) => ({\n  baseLocale: \"en\",\n  tempPath: \"./node_modules/typesafe-i18n/temp-output/\",\n  outputPath: \"./src/i18n/\",\n  outputFormat: \"TypeScript\",\n  typesFileName: \"i18n-types\",\n  utilFileName: \"i18n-util\",\n  formattersTemplateFileName: \"formatters\",\n  typesTemplateFileName: \"custom-types\",\n  esmImports: false,\n  adapter: void 0,\n  generateOnlyTypes: false,\n  banner: \"/* eslint-disable */\",\n  runAfterGenerator: void 0,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...config\n});\nvar readConfigFromDisk = async (fs) => {\n  const content = await fs.readFile(\".typesafe-i18n.json\").catch(() => \"{}\");\n  return JSON.parse(content.toString());\n};\nvar getConfig = async (fs) => {\n  const config = await readConfigFromDisk(fs);\n  return applyDefaultValues(config);\n};\nvar getLocaleInformation = async (fs) => {\n  const config = await getConfig(fs);\n  return {\n    base: config.baseLocale,\n    locales: await getAllLocales(fs, config.outputPath, config.outputFormat)\n  };\n};\nexport {\n  getConfig,\n  getLocaleInformation\n};\n", "import type { NodeishFilesystemSubset } from '@inlang/plugin'\nimport type { readdir } from \"node:fs/promises\"\n\n// ------------------------------------------------------------------------------------------------\n\n// TODO: test\nexport const getDictionaryForLocale = async (\n\t$fs: NodeishFilesystemSubset,\n\toutputPath: string,\n\tlocale: string\n) => {\n\t// TODO: create a better, less hacky version\n\tconst baseDictionary = await $fs.readFile(resolve(outputPath, `${locale}/index.ts`), { encoding: \"utf-8\" }).catch(() => undefined) as string\n\tif (!baseDictionary) return\n\n\tconst withoutImports = baseDictionary\n\t\t.split(\"\\n\")\n\t\t.filter((line) => !line.trim().startsWith(\"import \"))\n\t\t.join(\"\\n\")\n\tconst withoutTypes = withoutImports\n\t\t.replace(/const\\s\\w[^\\s]+\\s*(:\\s*\\w[^\\s]+\\s*)=/g, (match, type) => match.replace(type, \"\"))\n\tconst withoutSatisfies = withoutTypes.replace(/ satisfies.*\\/n/g, \"\\n\")\n\n\tconst moduleWithMimeType = \"data:application/javascript,\" + encodeURIComponent(withoutSatisfies)\n\treturn (await import(/* @vite-ignore */ moduleWithMimeType)).default\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport const patchFs = (fs: NodeishFilesystemSubset) => {\n\treturn {\n\t\t...fs,\n\t\treaddir: async (path: string, options?: Parameters<typeof readdir>[1]) => {\n\t\t\tconst result = await fs.readdir(path)\n\t\t\tif (!options?.withFileTypes) return result\n\n\t\t\treturn result.map(name => ({\n\t\t\t\tname,\n\t\t\t\tisDirectory: () => !(name.endsWith('.ts') || name.endsWith('.js')),\n\t\t\t}))\n\t\t},\n\t\treadFile: async (path: string) => {\n\t\t\tconst result = await fs.readFile(path)\n\n\t\t\treturn Buffer.from(result as unknown as string).toString()\n\t\t},\n\t} as unknown as NodeishFilesystemSubset\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport const resolve = (...parts: string[]): string =>\n\tparts\n\t\t.map((p) => {\n\t\t\twhile (p.startsWith(\"/\")) {\n\t\t\t\tp = p.substring(1)\n\t\t\t}\n\t\t\twhile (p.endsWith(\"/\")) {\n\t\t\t\tp = p.substring(0, p.length - 1)\n\t\t\t}\n\t\t\treturn p\n\t\t})\n\t\t.join(\"/\")\n", "// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isUndefined/isUndefined.js\nvar isNotUndefined = (value) => value !== void 0;\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/isString/isString.js\nvar isString = (value) => typeof value === \"string\";\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/pick/pick.js\nvar pick = (property) => (value) => value[property];\n\n// ../../node_modules/.pnpm/typesafe-utils@1.16.2/node_modules/typesafe-utils/lib/esm/uniqueArray/uniqueArray.js\nvar uniqueArray = (array) => Array.from(new Set(array));\n\n// src/basic.mts\nvar removeEmptyValues = (object) => Object.fromEntries(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Object.entries(object).map(([key, value]) => key !== \"i\" && value && value != \"0\" && [key, value]).filter(Boolean)\n);\nvar trimAllValues = (part) => Object.fromEntries(\n  Object.keys(part).map((key) => {\n    const val = part[key];\n    return [\n      key,\n      Array.isArray(val) ? val.map((v) => v?.trim()) : val === !!val ? val : val?.trim()\n    ];\n  })\n);\nvar parseArgumentPart = (text) => {\n  const [keyPart = \"\", ...formatterKeys] = text.split(\"|\");\n  const [keyWithoutType = \"\", type] = keyPart.split(\":\");\n  const [key, isOptional] = keyWithoutType.split(\"?\");\n  return { k: key, i: type, n: isOptional === \"\", f: formatterKeys };\n};\nvar isBasicPluralPart = (part) => !!(part.o || part.r);\nvar parsePluralPart = (content, lastAccessor) => {\n  let [key, values] = content.split(\":\");\n  if (!values) {\n    values = key;\n    key = lastAccessor;\n  }\n  const entries = values.split(\"|\");\n  const [zero, one, two, few, many, rest] = entries;\n  const nrOfEntries = entries.filter((entry) => entry !== void 0).length;\n  if (nrOfEntries === 1) {\n    return { k: key, r: zero };\n  }\n  if (nrOfEntries === 2) {\n    return { k: key, o: zero, r: one };\n  }\n  if (nrOfEntries === 3) {\n    return { k: key, z: zero, o: one, r: two };\n  }\n  return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };\n};\nvar REGEX_SWITCH_CASE = /^\\{.*\\}$/;\nvar parseCases = (text) => Object.fromEntries(\n  removeOuterBrackets(text).split(\",\").map((part) => part.split(\":\")).reduce(\n    (accumulator, entry) => {\n      if (entry.length === 2) {\n        return [...accumulator, entry.map((entry2) => entry2.trim())];\n      }\n      ;\n      accumulator[accumulator.length - 1][1] += \",\" + entry[0];\n      return accumulator;\n    },\n    []\n  )\n);\nvar REGEX_BRACKETS_SPLIT = /(\\{(?:[^{}]+|\\{(?:[^{}]+)*\\})*\\})/g;\nvar removeOuterBrackets = (text) => text.substring(1, text.length - 1);\nvar parseRawText = (rawText, optimize = true, firstKey = \"\", lastKey = \"\") => rawText.split(REGEX_BRACKETS_SPLIT).map((part) => {\n  if (!part.match(REGEX_BRACKETS_SPLIT)) {\n    return part;\n  }\n  const content = removeOuterBrackets(part);\n  if (content.startsWith(\"{\")) {\n    return parsePluralPart(removeOuterBrackets(content), lastKey);\n  }\n  const parsedPart = parseArgumentPart(content);\n  lastKey = parsedPart.k || lastKey;\n  !firstKey && (firstKey = lastKey);\n  return parsedPart;\n}).map((part) => {\n  if (typeof part === \"string\")\n    return part;\n  if (!part.k)\n    part.k = firstKey || \"0\";\n  const trimmed = trimAllValues(part);\n  return optimize ? removeEmptyValues(trimmed) : trimmed;\n});\n\n// src/advanced/parse.mts\nvar isTextPart = (part) => part.kind === \"text\";\nvar isPluralPart = (part) => part.kind === \"plural\";\nvar isParameterPart = (part) => part.kind === \"parameter\";\nvar isTransformParameterSwitchCasePart = (part) => part.kind === \"switch-case\";\nvar parseMessage = (message) => enhanceTypeInformation(parseRawText(message, false).map(createPart).filter(isNotUndefined));\nvar createPart = (part) => {\n  if (isString(part)) {\n    return part ? createTextPart(part) : void 0;\n  }\n  if (isBasicPluralPart(part))\n    return createPluralPart(part);\n  return createParameterPart(part);\n};\nvar createTextPart = (content) => ({\n  kind: \"text\",\n  content\n});\nvar createPluralPart = ({ k, z, o, t, f, m, r }) => ({\n  kind: \"plural\",\n  key: k,\n  ...z ? { zero: z } : void 0,\n  ...o ? { one: o } : void 0,\n  ...t ? { two: t } : void 0,\n  ...f ? { few: f } : void 0,\n  ...m ? { many: m } : void 0,\n  other: r\n});\nvar createParameterPart = ({ k, i, n, f }) => ({\n  kind: \"parameter\",\n  key: k,\n  types: i ? [i] : [],\n  optional: n || false,\n  transforms: (f || []).map(createTransformParameterPart)\n});\nvar createTransformParameterPart = (transform) => {\n  const isSwitchCase = transform.match(REGEX_SWITCH_CASE);\n  return isSwitchCase ? {\n    kind: \"switch-case\",\n    cases: Object.entries(parseCases(transform)).map(([key, value]) => ({ key, value })),\n    raw: transform\n  } : {\n    kind: \"formatter\",\n    name: transform\n  };\n};\nvar enhanceTypeInformation = (parts) => {\n  const parameterParts = parts.filter(isParameterPart);\n  const pluralParts = parts.filter(isPluralPart);\n  const typeMap = {};\n  parameterParts.forEach(({ key, types, transforms, optional }) => {\n    const enhancedTypes = types.length ? types : parseTypesFromSwitchCaseStatement(transforms);\n    typeMap[key] = {\n      types: uniqueArray([...typeMap[key]?.types || [], ...enhancedTypes]).filter(isNotUndefined),\n      optional: typeMap[key]?.optional || optional\n    };\n  });\n  pluralParts.forEach(({ key }) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"string\", \"number\", \"boolean\"], optional: false };\n    }\n  });\n  Object.keys(typeMap).forEach((key) => {\n    if (!typeMap[key]?.types.length) {\n      typeMap[key] = { types: [\"unknown\"], optional: typeMap[key]?.optional || false };\n    }\n  });\n  Object.entries(typeMap).forEach(([key, value]) => {\n    const part = parameterParts.find((p) => p.key === key);\n    if (!part)\n      return;\n    part.types = value.types;\n    part.optional = part.optional || value.optional;\n  });\n  return parts;\n};\nvar parseTypesFromSwitchCaseStatement = (formatters) => {\n  if (!formatters?.length)\n    return [];\n  const formatter = formatters[0];\n  if (!isTransformParameterSwitchCasePart(formatter))\n    return [];\n  const keys = formatter.cases.map(pick(\"key\"));\n  return keys.map((key) => key === \"*\" ? \"string\" : `'${key}'`);\n};\n\n// src/advanced/serialize.mts\nvar serializeMessage = (parts) => parts.map(serializePart).join(\"\");\nvar serializePart = (part) => {\n  if (isTextPart(part))\n    return part.content;\n  if (isPluralPart(part))\n    return serializePluralPart(part);\n  return serializeParameterPart(part);\n};\nvar serializePluralPart = ({ zero, one, two, few, many, other }) => `{{${[zero, one, two, few, many, other].filter((value) => value !== void 0).join(\"|\")}}}`;\nvar serializeParameterPart = ({ key, optional, types, transforms }) => {\n  const type = types.length === 1 ? types[0] === \"unknown\" ? void 0 : types[0] : void 0;\n  return `{${key}${type ? `:${type}` : \"\"}${optional ? \"?\" : \"\"}${transforms.length ? `|${transforms.map(serializeTransformPart).join(\"|\")}` : \"\"}}`;\n};\nvar serializeTransformPart = (transform) => transform.kind === \"formatter\" ? transform.name : transform.raw || serializeTransformSwitchCasePart(transform);\nvar serializeTransformSwitchCasePart = (part) => `{${part.cases.map(({ key, value }) => `${key}:${value}`).join(\",\")}}`;\nexport {\n  parseMessage as experimentalParseMessage,\n  serializeMessage as experimentalSerializeMessage\n};\n", "import type { Message, Plugin } from \"@inlang/plugin\"\nimport type { Pattern, Text, VariableReference } from \"@inlang/messages\"\nimport { getConfig } from 'typesafe-i18n/config'\nimport type { BaseTranslation } from 'typesafe-i18n'\nimport { getDictionaryForLocale, patchFs } from './typesafe-i18n.utils.js'\nimport { experimentalParseMessage, type ParameterPart, type PluralPart } from 'typesafe-i18n/parser'\n\ntype DictionaryMetadata = {\n\tlanguageTag: string\n\tdictionary: BaseTranslation\n}\n\nexport const loadMessages = (async ({ nodeishFs, languageTags }) => {\n\tconst $fs = patchFs(nodeishFs)\n\n\t// @ts-expect-error - the types slightly differ; should work regardless\n\tconst typesafeI18nConfig = await getConfig($fs)\n\n\tconst dictionaries = (await Promise.all<DictionaryMetadata | undefined>(languageTags\n\t\t.map(async languageTag => {\n\t\t\tconst dictionary = await getDictionaryForLocale(\n\t\t\t\t$fs,\n\t\t\t\ttypesafeI18nConfig.outputPath,\n\t\t\t\tlanguageTag,\n\t\t\t)\n\n\t\t\tif (!dictionary) return\n\n\t\t\treturn {\n\t\t\t\tlanguageTag,\n\t\t\t\tdictionary,\n\t\t\t}\n\t\t})\n\t)).filter(Boolean) as DictionaryMetadata[]\n\n\treturn getMessagesFromDictionaries(dictionaries)\n}) satisfies Plugin['loadMessages']\n\n// ------------------------------------------------------------------------------------------------\n\nconst getMessagesFromDictionaries = (dictionaries: DictionaryMetadata[]): Message[] => {\n\tconst messages: Message[] = []\n\tfor (const { languageTag, dictionary } of dictionaries) {\n\t\tconst entries = getFlatDictionary(dictionary)\n\t\tfor (const entry of entries) {\n\t\t\tlet foundMessage = messages.find(({ id }) => id === entry.id)\n\t\t\tif (!foundMessage) {\n\t\t\t\tfoundMessage = { id: entry.id, selectors: [], body: {} }\n\t\t\t\tmessages.push(foundMessage)\n\t\t\t}\n\n\t\t\tfoundMessage.body[languageTag] = [{ match: {}, pattern: parsePattern(entry.value) }]\n\t\t}\n\t}\n\n\treturn messages\n}\n\ntype FlattenedDictionaryMetadata = { id: string, value: string }[]\n\nconst getFlatDictionary = (dictionary: BaseTranslation): FlattenedDictionaryMetadata => {\n\treturn Object.entries(dictionary).map(([id, value]) => getFlatDictionaryEntry(id, value)).flat()\n}\n\nconst getFlatDictionaryEntry = (id: string, value: BaseTranslation): FlattenedDictionaryMetadata => {\n\tif (typeof value === 'object') {\n\t\treturn Object.entries(value)\n\t\t\t.map(([entryId, entryValue]) => getFlatDictionaryEntry(`${id}.${entryId}`, entryValue))\n\t\t\t.flat()\n\t}\n\n\treturn [{ id, value }]\n}\n\n// ------------------------------------------------------------------------------------------------\n\nconst parsePattern = (value: string): Pattern => {\n\tconst parsedMessage = experimentalParseMessage(value)\n\n\treturn parsedMessage.map(part => {\n\t\tswitch (part.kind) {\n\t\t\tcase 'parameter':\n\t\t\t\treturn parseParameter(part)\n\t\t\tcase 'text':\n\t\t\t\treturn { type: \"Text\", value: part.content }\n\t\t\tcase 'plural':\n\t\t\t\treturn parsePlural(part)\n\t\t}\n\t})\n\n}\n\nconst parseParameter = (parameterPart: ParameterPart): VariableReference => {\n\treturn {\n\t\ttype: 'VariableReference',\n\t\tname: parameterPart.key,\n\t\t// TODO: find a way to add metadata\n\t\t// metadata: {\n\t\t// \ttypes: parameterPart.types,\n\t\t// \toptional: parameterPart.optional,\n\t\t// \ttransforms: parameterPart.transforms,\n\t\t// }\n\t}\n}\n\n// TODO: make this more robust\nconst parsePlural = (pluralPart: PluralPart): Text => {\n\treturn {\n\t\ttype: \"Text\",\n\t\tvalue: `{{${[pluralPart.zero, pluralPart.one, pluralPart.two, pluralPart.few, pluralPart.many, pluralPart.other]\n\t\t\t.filter(Boolean)\n\t\t\t.join('|')\n\t\t\t}}}`\n\t}\n}", "import type { Plugin } from \"@inlang/plugin\"\n\nexport const saveMessages = (async (options) => {\n\n}) satisfies Plugin['saveMessages']", "import type { Plugin } from \"@inlang/plugin\"\nimport { loadMessages } from './loadMessages.js'\nimport { saveMessages } from './writeMessages.js'\n\nexport const plugin = {\n  meta: {\n    id: \"ivanhofer.inlang-plugin-typesafe-i18n\",\n    displayName: { en: \"typesafe-i18n plugin\" },\n    description: { en: \"A plugin for inlang that uses typesafe-i18n to read and write messages\" },\n    keywords: [\"inlang\", \"plugin\", \"typesafe-i18n\", \"TypeScript\"],\n  },\n  loadMessages,\n  saveMessages,\n} satisfies Plugin\n", "import type { InlangModule } from \"@inlang/module\"\nimport { plugin } from './plugin.js'\n\nexport default {\n\tplugins: [plugin],\n} satisfies InlangModule['default']"],
  "mappings": "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",
  "names": ["applyDefaultValues", "config", "readConfigFromDisk", "fs", "content", "getConfig", "getDictionaryForLocale", "$fs", "outputPath", "locale", "baseDictionary", "resolve", "withoutSatisfies", "line", "match", "type", "patchFs", "fs", "path", "options", "result", "name", "parts", "p", "isNotUndefined", "value", "isString", "pick", "property", "uniqueArray", "array", "removeEmptyValues", "object", "key", "trimAllValues", "part", "val", "v", "parseArgumentPart", "text", "keyPart", "formatterKeys", "keyWithoutType", "type", "isOptional", "isBasicPluralPart", "parsePluralPart", "content", "lastAccessor", "values", "entries", "zero", "one", "two", "few", "many", "rest", "nrOfEntries", "entry", "REGEX_SWITCH_CASE", "parseCases", "removeOuterBrackets", "accumulator", "entry2", "REGEX_BRACKETS_SPLIT", "parseRawText", "rawText", "optimize", "firstKey", "lastKey", "parsedPart", "trimmed", "isPluralPart", "part", "isParameterPart", "isTransformParameterSwitchCasePart", "parseMessage", "message", "enhanceTypeInformation", "parseRawText", "createPart", "isNotUndefined", "isString", "createTextPart", "isBasicPluralPart", "createPluralPart", "createParameterPart", "content", "k", "z", "o", "t", "f", "m", "r", "i", "n", "createTransformParameterPart", "transform", "REGEX_SWITCH_CASE", "parseCases", "key", "value", "parts", "parameterParts", "pluralParts", "typeMap", "types", "transforms", "optional", "enhancedTypes", "parseTypesFromSwitchCaseStatement", "uniqueArray", "p", "formatters", "formatter", "pick", "loadMessages", "nodeishFs", "languageTags", "$fs", "patchFs", "typesafeI18nConfig", "getConfig", "dictionaries", "languageTag", "dictionary", "getDictionaryForLocale", "getMessagesFromDictionaries", "messages", "entries", "getFlatDictionary", "entry", "foundMessage", "id", "parsePattern", "value", "getFlatDictionaryEntry", "entryId", "entryValue", "parseMessage", "part", "parseParameter", "parsePlural", "parameterPart", "pluralPart", "saveMessages", "options", "plugin", "loadMessages", "saveMessages", "src_default", "plugin"]
}
